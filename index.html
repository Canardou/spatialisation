<html>
    <head>
        <script type="text/javascript" src="jsfeat.js"></script>
    </head>
    <body>
        <video id="file" autoplay loop style="display: none;">
            <source src=IRIT01.webm type=video/webm>
        </video>
        <p><canvas id="canvas"></canvas></p>
        <script type="text/javascript">
        /* global jsfeat */
        "use strict";
        var file = document.getElementById('file');
        //file.playbackRate = 0.5;
        var canvas = document.getElementById('canvas');
        var videoStream = null;
        
        var curr_img_pyr = new jsfeat.pyramid_t(3);
        var prev_img_pyr = new jsfeat.pyramid_t(3);
        var win_size = 20,
            max_iterations = 30,
            epsilon = 0.01,
            min_eigen = 0.001;
            
        var point_count = 50;
        
        var prev_xy = new Float32Array(point_count*2);
        var curr_xy = new Float32Array(point_count*2);
        var reset_point = 0;
        var point_status = new Uint8Array(point_count);
        var point_id_followed = new Uint8Array(point_count);
        var point_speed = new Float32Array(point_count);
        var point_direction = [];
        var point = [];
        
        window.onload=function(){
            curr_img_pyr.allocate(canvas.width, canvas.height, jsfeat.U8_t|jsfeat.C1_t);
            prev_img_pyr.allocate(canvas.width, canvas.height, jsfeat.U8_t|jsfeat.C1_t);
            for(var k=0; k<point_count; k++){
        	    var coords = {x:Math.floor(Math.random()*canvas.width), y:30+Math.floor(Math.random()*(canvas.height-60))}; 
                curr_xy[k<<1] = coords.x;
                curr_xy[(k<<1)+1] = coords.y;
            }
            setInterval(snapshot, 100);
        }
            
        function snapshot()
        {
        	canvas.width = file.videoWidth;
        	canvas.height = file.videoHeight;
        	
    	    for(var i=0; i<point_count; i++){
    	        if((point_speed[i] == 0 && reset_point == 0) || point_status[i] == 0){
            	    var coords = {x:Math.floor(Math.random()*canvas.width), y:30+Math.floor(Math.random()*(canvas.height-60))}; 
                    curr_xy[i<<1] = coords.x;
                    curr_xy[(i<<1)+1] = coords.y;
    	        }
    	    }
        	reset_point = (reset_point+1)%2;
        	
        	var ctx = canvas.getContext('2d');
        	ctx.drawImage(file, 0, 0);
        	try{
            	draw_circle(ctx, mouse.x, mouse.y);
            	var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            	
                var pixels = imageData.data;
                 
                var gray_img = new jsfeat.matrix_t(canvas.width, canvas.height, jsfeat.U8_t | jsfeat.C1_t);
                var code = jsfeat.COLOR_RGBA2GRAY;
                
                var _pyr = prev_img_pyr;
                prev_img_pyr = curr_img_pyr;
                curr_img_pyr = _pyr;
                var _pt_xy = prev_xy;
                prev_xy = curr_xy;
                curr_xy = _pt_xy;
                
                jsfeat.imgproc.grayscale(imageData.data, canvas.width, canvas.height, curr_img_pyr.data[0], code);
                
                curr_img_pyr.build(curr_img_pyr.data[0], true);
                jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, win_size, max_iterations, point_status, epsilon, min_eigen);
                
                /*var data_u32 = new Uint32Array(imageData.data.buffer);
                var alpha = (0xff << 24);
                var i = curr_img_pyr.data[0].cols*curr_img_pyr.data[0].rows, pix = 0;
                while(--i >= 0) {
                    pix = curr_img_pyr.data[0].data[i];
                    data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;
                }*/

                //draw points remove too high speed (win size = 20)
                prune_oflow_points(ctx);
                
                //find same direction vectors (distance point to point < winsize)
                //almost same direction
                
                for(var j = 0; j < point_count; ++j) {
                    point_id_followed[j] = 255;
                }
                
                for(var j = 0; j < point_count; ++j) {
                    if(point_status[j] == 1 && point_speed[j] > 0 && point_id_followed[j] == 255) {
                        for(var k = j; k < point_count; ++k) {
                            if(point_status[k] == 1 && point_id_followed[k] == 255) {
                                if( k != j ){
                                    if(point_speed[k] > 0 && point_direction[k].x != Infinity && point_direction[k].y != Infinity){
                                        var distance = Math.sqrt((point[j].x-point[k].x)*(point[j].x-point[k].x) + (point[j].y-point[k].y)*(point[j].y-point[k].y));
                                        var dot_result = point_direction[k].x * point_direction[j].x + point_direction[k].y * point_direction[j].y;
                                        var speed_diff = Math.abs(point_speed[k]-point_speed[j]);
                                        if( dot_result > 0.9 && distance < win_size*2 && speed_diff < 5){
                                            point_id_followed[k] = j
                                            point_id_followed[j] = j
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                for(var i=0; i < point_count; ++i) {
                    if(point_status[i] == 1 && point_id_followed[i] == i) {
                        draw_line(ctx, point[i].x, point[i].y, point_direction[i], point_speed[i], "red");
                    }
                }
                
                //should iterate a second time to merge close found vector and keep them in memory in between frame (kalman ?)
                
                
        	}
        	catch (e){
        	    console.log(e);
        	}
        }
        
        function draw_circle(ctx, x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'yellow';
            ctx.fill();
        }

        function draw_line(ctx, x, y, velocity, speed, color) {
            ctx.beginPath();
            ctx.moveTo(x,y);
            ctx.lineTo(x+velocity.x*speed,y+velocity.y*speed);
            ctx.strokeStyle = color;
            ctx.lineWidth=5;
            ctx.stroke();
        }

        var sound_avg = 0;
        function prune_oflow_points(ctx) {
            var n = point_count;
            var i=0;
            var sound = 0;
            for(; i < n; ++i) {
                if(point_status[i] == 1) {
                    var velocity = {x:prev_xy[i<<1]-curr_xy[i<<1], y:prev_xy[(i<<1)+1]-curr_xy[(i<<1)+1]}
                    point[i] = {x:prev_xy[i<<1], y:prev_xy[(i<<1)+1]}
                    var speed = Math.floor(Math.sqrt(velocity.x*velocity.x + velocity.y*velocity.y));
                    point_direction[i] = {x:velocity.x/speed, y:velocity.y/speed};
                    speed = Math.min(Math.max(0,speed),255);
                    point_speed[i] = speed;
                    if(speed > win_size)
                        point_status[i] = 0;
                    //else
                    //    draw_line(ctx, prev_xy[i<<1], prev_xy[(i<<1)+1], point_direction[i], speed, "green");
                }
            }
        }
        
        
        var mouse;
        function getMousePos(evt) {
            var rect = canvas.getBoundingClientRect();
            mouse = {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
            };
        }
        window.addEventListener('mousemove', getMousePos, false);
        
        
        // crÃ©e un contexteaudio
        var contexteAudio = new (window.AudioContext || window.webkitAudioContext)();
        
        // create Oscillator node
        var oscillator = contexteAudio.createOscillator();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(440, 0); // valeur en hertz
        oscillator.detune.setValueAtTime(0.2, 0);

        var gainNode = contexteAudio.createGain();
        oscillator.connect(gainNode);
        gainNode.connect(contexteAudio.destination);
        gainNode.gain.setValueAtTime(0, contexteAudio.currentTime);
        
        oscillator.start();
        //oscillator.stop(contexteAudio.currentTime + 0.1);
        </script>
    </body>
</html>