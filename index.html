<html>
    <head>
        <script type="text/javascript" src="jsfeat.js"></script>
    </head>
    <body>
        <button id="play_pause" onclick="play_pause()" type="button">Pause</button>
        <video id="file" autoplay loop style="display: none;">
            <source src=IRIT01.webm type=video/webm>
        </video>
        <p><canvas id="canvas"></canvas></p>
        <input type="checkbox" autocomplete=off onchange="setDebug(this.checked)" id="debug" value="debug"><label for="debug">Debug</label>
        <div id="log"></div>
        <script type="text/javascript">
        /* global jsfeat */
        "use strict";
        var debug = false;
        function setDebug(bool){
            debug = bool;
        }
        var file = document.getElementById('file');
        var btn = document.getElementById('play_pause');
        
        
        function play_pause() {
          if(file.paused) {
              file.play();
              btn.innerHTML = "Pause";
          }
          else {
              file.pause();
              btn.innerHTML = "Play";
          }
        } 
        
        //file.playbackRate = 0.5;
        var canvas = document.getElementById('canvas');
        var videoStream = null;
        
        var curr_img_pyr = new jsfeat.pyramid_t(3);
        var prev_img_pyr = new jsfeat.pyramid_t(3);
        var win_size = 25,
            max_iterations = 30,
            epsilon = 0.01,
            min_eigen = 0.001;
            
        var point_count = 200;
        var win_size_sq = win_size*win_size;
        
        var prev_xy = new Float32Array(point_count*2);
        var curr_xy = new Float32Array(point_count*2);
        var point_status = new Uint8Array(point_count);
        var point_id_followed = new Uint8Array(point_count);
        var point_id_follower_count = new Uint8Array(point_count);
        var point_speed = new Float32Array(point_count);
        var point_direction = [];
        var point = [];
        var objects = [];
        var reset_point = 0;
        
        window.onload=function(){
            curr_img_pyr.allocate(canvas.width, canvas.height, jsfeat.U8_t|jsfeat.C1_t);
            prev_img_pyr.allocate(canvas.width, canvas.height, jsfeat.U8_t|jsfeat.C1_t);
            for(var k=0; k<point_count; k++){
        	    var coords = {x:Math.floor(Math.random()*canvas.width), y:30+Math.floor(Math.random()*(canvas.height-60))}; 
                curr_xy[k<<1] = coords.x;
                curr_xy[(k<<1)+1] = coords.y;
            }
            setInterval(snapshot, 100);
            
            if(listener.forwardX) {
              listener.forwardX.value = 0;
              listener.forwardY.value = 0;
              listener.forwardZ.value = -1;
              listener.upX.value = 0;
              listener.upY.value = 1;
              listener.upZ.value = 0;
            } else {
              listener.setOrientation(0,0,-1,0,1,0);
            }
            listener.positionX.value = canvas.width/2;
            listener.positionY.value = canvas.height/2;
            listener.positionZ.value = 50;
            
            panner.setPosition(0,0,0);
        }
            
        function snapshot()
        {
          if(file.paused)
              return;
        
        	canvas.width = file.videoWidth;
        	canvas.height = file.videoHeight;
        	
    	    for(var i=0; i<point_count; i++){
    	        if(point_speed[i] < 0.1 || point_status[i] == 0 || reset_point == i){
            	    var coords = {x:Math.floor(Math.random()*canvas.width), y:30+Math.floor(Math.random()*(canvas.height-60))}; 
                    curr_xy[i<<1] = coords.x;
                    curr_xy[(i<<1)+1] = coords.y;
    	        }
    	    }
    	    reset_point = (reset_point+1)%point_count;
        	
        	var ctx = canvas.getContext('2d');
        	ctx.drawImage(file, 0, 0);
        	try{
        	    if(mouse)
            	    draw_circle(ctx, mouse.x, mouse.y);
            	    
            	var t0 = performance.now();
                var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            	
                var pixels = imageData.data;
                 
                var gray_img = new jsfeat.matrix_t(canvas.width, canvas.height, jsfeat.U8_t | jsfeat.C1_t);
                var code = jsfeat.COLOR_RGBA2GRAY;
                
                var _pyr = prev_img_pyr;
                prev_img_pyr = curr_img_pyr;
                curr_img_pyr = _pyr;
                var _pt_xy = prev_xy;
                prev_xy = curr_xy;
                curr_xy = _pt_xy;
                
                jsfeat.imgproc.grayscale(imageData.data, canvas.width, canvas.height, curr_img_pyr.data[0], code);
                
                curr_img_pyr.build(curr_img_pyr.data[0], true);
                var t1 = performance.now();
                jsfeat.optical_flow_lk.track(prev_img_pyr, curr_img_pyr, prev_xy, curr_xy, point_count, win_size, max_iterations, point_status, epsilon, min_eigen);
                var t2 = performance.now();
                /*var data_u32 = new Uint32Array(imageData.data.buffer);
                var alpha = (0xff << 24);
                var i = curr_img_pyr.data[0].cols*curr_img_pyr.data[0].rows, pix = 0;
                while(--i >= 0) {
                    pix = curr_img_pyr.data[0].data[i];
                    data_u32[i] = alpha | (pix << 16) | (pix << 8) | pix;
                }*/

                //draw points remove too high speed (win size = 20)
                prune_oflow_points(ctx);
                var t3 = performance.now();
                //find same direction vectors (distance point to point < winsize)
                //almost same direction
                
                for(var j = 0; j < point_count; ++j) {
                    point_id_followed[j] = 255;
                    point_id_follower_count[j] = 0;
                }
                
                objects = [];
                
                for(var j = 0; j < point_count/2; ++j) {
                    if(!is_valid_point(j))
                        continue;
                    
                    for(var k = j+1; k < point_count; ++k) {
                        if(!is_valid_point(k))
                            continue;
                        
                        var distance = (point[j].x-point[k].x)*(point[j].x-point[k].x) + (point[j].y-point[k].y)*(point[j].y-point[k].y);
                        var dot_result = point_direction[k].x * point_direction[j].x + point_direction[k].y * point_direction[j].y;
                        var speed_diff = Math.abs(point_speed[k]-point_speed[j]);
                        
                        if( dot_result > 0.9 && distance < win_size_sq*8 && speed_diff < 2){
                            if(objects[j] == undefined){
                                objects[j] = {id:j, left:point[j].x, 
                                                    top:point[j].y,
                                                    right:point[j].x,
                                                    bottom:point[j].y};
                            }
                            objects[j] = {id:objects[j].id, left:Math.min(objects[j].left,point[k].x), 
                                                    top:Math.min(objects[j].top,point[k].y),
                                                    right:Math.max(objects[j].right,point[k].x),
                                                    bottom:Math.max(objects[j].bottom,point[k].y)};
                            point_id_followed[k] = j
                            point_id_followed[j] = j
                            point_id_follower_count[j]++;
                            point[j].x = (point[j].x+point[k].x)/2;
                            point[j].y = (point[j].y+point[k].y)/2;
                            point_direction[j].x = (point_direction[j].x+point_direction[k].x)/2;
                            point_direction[j].y = (point_direction[j].y+point_direction[k].y)/2;
                            var length = Math.floor(Math.sqrt(point_direction[j].x*point_direction[j].x + point_direction[j].y*point_direction[j].y));
                            point_direction[j].x /= length;
                            point_direction[j].y /= length;
                            point_speed[j] = (point_speed[k]+point_speed[j])/2;
                        }
                    }
                }
                
                var t4 = performance.now();
                // reset at max distance to "stop" listenning 
                // fix huge noise when starting the video

                document.getElementById("log").innerHTML = "";
                
                var max_speed = 0;
                for(var i=0; i < point_count; ++i) {
                    if(point_status[i] == 1 && point_id_follower_count[i] > 3) {
                        if(debug)
                            draw_line(ctx, point[i].x, point[i].y, point_direction[i], point_speed[i], "red");
                        if(max_speed < point_speed[i]){
                            max_speed = point_speed[i]
                            panner.setPosition(point[i].x,point[i].y,0);
                            //panner.setVelocity(point_direction[i].x, point_direction[i].y, 0);//Firefox only
                            gainNode.gain.setValueAtTime(point_speed[i], contexteAudio.currentTime);
                            if(debug){
                                ctx.beginPath();
                                ctx.lineWidth="2";
                                ctx.strokeStyle="blue";
                                ctx.rect(objects[i].left,objects[i].top,objects[i].right-objects[i].left,objects[i].bottom-objects[i].top);
                                ctx.stroke();
                                ctx.font = "15px Comic Sans MS";
                                ctx.fillStyle = "blue";
                                ctx.textAlign = "center";
                                ctx.fillText("id:" + objects[i].id, objects[i].left, objects[i].top - 15); 
                            }
                            if(debug)
                                document.getElementById("log").innerHTML += "<div>Objects "+objects[i].id+"<br>Speed : "+Math.floor(point_speed[i])+"<br>x:"+Math.floor(objects[i].left)+", y:"+Math.floor(objects[i].top)+", w:"+Math.floor(objects[i].right-objects[i].left)+", h:"+Math.floor(objects[i].bottom-objects[i].top)+"</div>";
                        }
                    }
                }
                
                gainNode.gain.setValueAtTime(max_speed, contexteAudio.currentTime);
                
                var t5 = performance.now();
                if(debug)
                    document.getElementById("log").innerHTML += "<div style='position:absolute;display:block;top:20px;left:400px'><br>Preparation donnees : " + Math.floor(t1-t0)
                                                            +"<br>Lukas kanade : " + Math.floor(t2-t1)
                                                            +"<br>Tri des points : " + Math.floor(t3-t2)
                                                            +"<br>Rassemblement des points : " + Math.floor(t4-t3)
                                                            +"<br>Affichage et son : " + Math.floor(t5-t4) + "</div>";
                //should iterate a second time to merge close found vector and keep them in memory in between frame (kalman ?)
                
                
        	}
        	catch (e){
        	    console.log(e);
        	}
        }
        
        function is_valid_point(j) {
            return point_status[j] == 1
                && point_speed[j] > 0
                && point_id_followed[j] == 255
                && point_direction[j].x != Infinity
                && point_direction[j].y != Infinity;
        }
        
        function draw_circle(ctx, x, y) {
            ctx.beginPath();
            ctx.arc(x, y, 12, 0, 2 * Math.PI, false);
            ctx.fillStyle = 'black';
            ctx.fill();
        }

        function draw_line(ctx, x, y, velocity, speed, color) {
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x,y);
            ctx.lineTo(x+1+velocity.x*speed,y+1+velocity.y*speed);
            ctx.strokeStyle = color;
            ctx.lineWidth=5;
            ctx.stroke();
        }

        var sound_avg = 0;
        function prune_oflow_points(ctx) {
            var n = point_count;
            var i=0;
            var sound = 0;
            for(; i < n; ++i) {
                if(point_status[i] == 1) {
                    var velocity = {x:prev_xy[i<<1]-curr_xy[i<<1], y:prev_xy[(i<<1)+1]-curr_xy[(i<<1)+1]}
                    
                    var speed = Math.floor(Math.sqrt(velocity.x*velocity.x + velocity.y*velocity.y));
                        speed = Math.min(Math.max(0,speed),255);
                    
                    point[i] = {x:prev_xy[i<<1], y:prev_xy[(i<<1)+1]}
                    point_direction[i] = {x:velocity.x/speed, y:velocity.y/speed};
                    point_speed[i] = speed;

                    if(speed > win_size)
                        point_status[i] = 0;
                    else if (debug)
                        draw_line(ctx, prev_xy[i<<1], prev_xy[(i<<1)+1], point_direction[i], speed, "green");
                }
            }
        }
        
        
        var mouse;
        function getMousePos(evt) {
            var rect = canvas.getBoundingClientRect();
            mouse = {
              x: evt.clientX - rect.left,
              y: evt.clientY - rect.top
            };
        }
        window.addEventListener('mousemove', getMousePos, false);
        
        // crée un contexteaudio
        var contexteAudio = new (window.AudioContext || window.webkitAudioContext)();
        
        var panner = contexteAudio.createPanner();
        panner.panningModel = 'HRTF';
        panner.distanceModel = 'inverse';
        panner.refDistance = 1;
        panner.maxDistance = 10000;
        panner.rolloffFactor = 1;
        panner.coneInnerAngle = 360;
        panner.coneOuterAngle = 0;
        panner.coneOuterGain = 0;
        
        var listener = contexteAudio.listener;
        
        var source;
        function getData() {
            source = contexteAudio.createBufferSource();
            var request = new XMLHttpRequest();
            
            request.open('GET', '7274.wav', true);
            
            request.responseType = 'arraybuffer';
            
            request.onload = function() {
            var audioData = request.response;
            
            contexteAudio.decodeAudioData(audioData, function(buffer) {
                var myBuffer = buffer;
                source.buffer = myBuffer;
                source.connect(gainNode);
                source.loop = true;
              },
            
              function(e){"Error with decoding audio data" + e.err});
            
            }
            
            request.send();
        }
            
        // wire up buttons to stop and play audio, and range slider control
        getData();
        source.start(0);

        
        // create Oscillator node
        var oscillator = contexteAudio.createOscillator();
        oscillator.type = 'square';
        oscillator.frequency.setValueAtTime(440, 0); // valeur en hertz
        oscillator.detune.setValueAtTime(0.2, 0);

        var gainNode = contexteAudio.createGain();
        gainNode.connect(panner);
        panner.connect(contexteAudio.destination);
        gainNode.gain.setValueAtTime(0.0, contexteAudio.currentTime);
        
        oscillator.start();
        //oscillator.stop(contexteAudio.currentTime + 0.1);
        </script>
    </body>
</html>